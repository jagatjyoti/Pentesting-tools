#!/usr/bin/python

print "\n \n \n"
print "    ############################################################################################### "
print "    ###########         PENTESTING PYTHON SUITE FOR REQRES (https://reqres.in/)         ########### "
print "    ###########    PLEASE RUN IT USING SUDO AS SOME SCRIPTS NEED ELEVATED PRIVILEGES    ########### "
print "    ############################################################################################### "
print "\n \n \n"
 
import os
import subprocess
import sys
from subprocess import Popen, PIPE
from scapy.all import *
import requests
import urllib2
import re
import time
 
def Is_Reqres_Up():
  try:
    r = requests.get('https://reqres.in/')
    print "Status code: ", r.status_code
#    print "Content: ", r.content
    if r.status_code == 200:
        print "reqres is up .... Proceeding ! \n "
        print "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n"
    else:
        print "Some problem occured while checking reqres status !!! \n"
        sys.exit(1)
  except requests.exceptions.RequestException as e:
    print "Exception caught .... \n"
    print e
    sys.exit(1)
 
def Register_User():

  try:
    headers = {'Content-Type': 'application/json'}
    data = '{"email":"zarvis@yahoo.com", "password":"imeverywhere"}'
    print "Register user with credentials: ", data
    r =  requests.post('https://reqres.in/api/register', headers=headers, data=data)
    print "Status code: ", r.status_code
#    print "Content: ", r.content
    if r.status_code == 201:
        print "User registered successfully ! \n "
        print "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n"
    else:
        print "Some problem occured while checking registering !!! \n"
        sys.exit(1)
  except requests.exceptions.RequestException as e:
    print "Exception caught .... \n"
    print e
    sys.exit(1)

 
def sensitive_data_transmitted_in_cleartext():
 
        print " TEST CASE # 1: SENSITIVE DATA TRANSMITTED IN CLEAR TEXT \n "
        print " DESCRIPTION: While making an API call a lot of information might be exposed if it's transmitted in clear text which can be easily decoded. \n "
        print " PROCEDURE: Making an API call to reqres and checking whether authentication is basic or encrypted \n "
        print " OBSERVATION: Prints Basic auth detected if mode is basic \n \n "
 
        print "************************* Testing for sensitive data transmitted in clear-text ******************************"
 
        print "Initiating API call ........ \n \n  "
        cmd = 'curl -s -vvv -X POST -H "Content-Type: application/json" https://reqres.in/api/login -d {"email":"zarvis@yahoo.com", "password":"imeverywhere"}'
        print cmd + "\n"
        s = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE)
        out, err = s.communicate()
        print "\n"
        print "API call completed ... \n \n"
        o = str(out)
        e = str(err)
        if "Basic" in o:
            print "XXXXXXXXXXXX   BASIC AUTH DETECTED  XXXXXXXXXXXX \n "
        else:
            print "Sensitive data sent in encrypted format ! \n " 
        if "Basic" in e:
            print "XXXXXXXXXXXX   BASIC AUTH DETECTED  XXXXXXXXXXXX \n "
        else: 
            print "Sensitive data sent in encrypted format ! \n "

        print ('\n\n\n')
        print ('\n#######################################################################################################\n')
 
 
def SSL_service_recognition_via_nmap():
 
        print " TEST CASE # 2: SSL SERVICE RECOGNITION VIA NMAP \n "
        print " DESCRIPTION: Some ports which are not needed to be necessarily open should be closed. If not they pose a security threat to the server. \n "
        print " PROCEDURE: Determining open ports using NMAP tool \n "
        print " OBSERVATION: Prints all open ports of the server  \n \n "
 
        print "*********************** Testing for SSL service recognition via nmap *****************************"
 
        print "Collecting port information ... "
        print "Open ports embedded to SSL/TLS are: \n"
        cmd = 'nmap -sV --reason -PN -n --top-ports 100 reqres.in | grep open'
#        s = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE)
        subprocess.call(cmd,shell=True)
#        out, err = s.communicate()
#        print  out
#        if len(err) != 0:
#                print "Error: \n", err
 
        print ('\n\n\n')
        print ('\n#######################################################################################################\n')
 
 
def Weak_Ciphers_and_SSLv2_via_nmap():
 
        print " TEST CASE # 3: WEAK_CIPHERS_AND_SSLV2_VIA_NMAP \n "
        print " DESCRIPTION: Weak Ciphers and older SSL version pose a serious threat to the server which should be checked. \n "
        print " PROCEDURE: Checking for weak ciphers and SSL versions with certificate strength \n "
        print " OBSERVATION: Prints all info pertaining to ciphers, SSL and certificate  \n \n "
 
        print "******************************Checking for Certificate information, Weak Ciphers and SSLv2 via nmap*******************"
        time.sleep(2)
 
        cmd = 'nmap --script ssl-cert,ssl-enum-ciphers -p 443,8443 reqres.in'
 
        s = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        out, err = s.communicate()
 
        print out
        if len(err) != 0:
                print "Error: ", err
 
        print ('\n\n\n')
 
        print ('\n#######################################################################################################\n')
 
def Client_initiated_Renegotiation_and_Secure_Renegotiation_via_openssl():
 
        print " TEST CASE # 4: SECURE RENEGOTIATION \n "
        print " DESCRIPTION: Secure renegotiaion should be supported by the server using OPENSSL. If not attacks like session hijacking may occur.\n "
        print " PROCEDURE: Python script tries to break the connection and initiates a renegotiation with the server. \n "
        print " OBSERVATION: Secure renegotiation should get established which should be printed in output  \n \n "
 
        print "**************************Checking for Client-initiated Renegotiation and Secure Renegotiation via openssl********************************"
 
        cmd = 'openssl s_client -connect reqres.in:443'
        p = Popen(cmd, shell=True,stdin=PIPE,stderr=PIPE, stdout=PIPE)
        out,err = p.communicate(input='R')
        print "Print output ",out
        print "Printing Error ", err
 
        print ('\n\n\n')
        print ('\n#######################################################################################################\n')
 
def Certificate_authenticity_and_web_related_validations():
 
        print " TEST CASE # 5: CERTIFICATE_AUTHENTICITY \n "
        print " DESCRIPTION: Certs should be valid and authenticated by proper CA \n "
        print " PROCEDURE: Python script tries to verify the certificate \n "
        print " OBSERVATION: Status code 200 without any error shows certificate verification is valid  \n \n "
 
        print "*********************************Checking for Certificate authenticity and web related validations***************************"
        try:
                r = requests.get('https://reqres.in', verify=True)
                print "Response code: ", r.status_code
#                print r.content
        except requests.exceptions.RequestException as e:
                print "Exception: \n", e
 
        print ('\n\n\n')
 
 
        print ('\n#######################################################################################################\n')
 
def SQL_injection_for_login_page():
 
        print " TEST CASE # 6: SQL_INJECTION \n "
        print " DESCRIPTION: SQL injection attacks allow attackers to spoof identity, tamper with existing data, cause repudiation issues such as voiding transactions or changing balance \n "
        print " PROCEDURE: Python script \n "
        print " OBSERVATION: Status code 200 without any error shows no tamperament  \n \n "
 
        print "*************************************************Checking for SQL injection for login page**********************************"
        try:
          headers = {'Content-Type': 'application/json'}
          data = '{"email":"zarvis@yahoo.com", "password":"lsdfklskdl#*#*)*(*3390"}'
          r = requests.post('https://reqres.in/api/login, headers=headers, data=data)
          print "Response code: ", r.status_code
          print r.json()
#          print type(r.json())
        except ValueError as e:
          print "Exception caught: \n", e
        print ('\n\n\n')
        print ('\n#######################################################################################################\n')
 
def Cross_site_scripting_XSS():
 
        print " TEST CASE # 7: CROSS_SITE_SCRIPTING_XSS \n "
        print " DESCRIPTION: It's a type of injection, in which malicious scripts are injected into trusted web sites \n "
        print " PROCEDURE: Python script \n "
        print " OBSERVATION: Output should show NO XSS found  \n \n "
 
        print "**********************************Testing for Cross site scripting (XSS) in website********************************"
 
        a = subprocess.Popen("git clone https://github.com/gbrindisi/xsssniper.git",stdout=subprocess.PIPE,shell=True)
        print a.communicate()
 
        b = subprocess.Popen('./xsssniper/xsssniper.py -u "https://reqres.in/"',stdout=subprocess.PIPE,shell=True)
        print b.stdout.read()
 
 
        print ('\n\n\n')
 
 
        print ('\n#######################################################################################################\n')
 
def CrossSite_Request_Forgery_facebook():
 
        print " TEST CASE # 8: CROSSSITE_REQUEST_FORGERY \n "
        print " DESCRIPTION: Its attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated \n "
        print " PROCEDURE: Initiating an API call to reqres and injecting a CSRF token with it \n "
        print " OBSERVATION: POST call should be successful  \n \n "
 
        print "*****************************************Testing for Cross-Site Request Forgery in reqres**************************"
        try:
 
                URL = 'https://facebook.com'
 
                client = requests.session()
 
# Retrieve the CSRF token first
                client.get(URL)  # sets cookie
                csrftoken = client.cookies['csrftoken']
 
                login_data = dict({"username":"zarvis", "password":"imeverywhere"}, csrfmiddlewaretoken=csrftoken, next='/')
                r = client.post(URL, data=login_data, headers=dict(Referer=URL))
                print "Response code: ", r.status_code
 
        except KeyError:
                print "KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))"
                print "name='csrftoken', domain=None, path=None"
 
        print ('\n\n\n')
 
        print ('\n#######################################################################################################\n')
 
def Session_hijacking_in_reqres():
 
        print " TEST CASE # 9: SESSION_HIJACKING \n "
        print " DESCRIPTION: It  consists of the exploitation of the web session control mechanism, which is normally managed for a session token.  \n "
        print " PROCEDURE: Initiating an API call and injecting cookie header to it \n "
        print " OBSERVATION: POST call should be successful  \n \n "
 
        print "*********************************Testing for Session hijacking in reqres**************************************"
 
        url = 'https://reqres.in'
        request = urllib2.Request(url)
        print 'Injecting cookie header ...'
        request.add_header('Cookie', 'xyz')
        response = urllib2.urlopen(request)
        print 'Response: ', response
        print "The URL is: ", response.geturl()
        print "Response code: ", response.code
        print "The Headers are: ", response.info()
 
 
        print ('\n\n\n')
 
        print ('\n#######################################################################################################\n')
 
def Boolean_Based_SQL_Injection():
 
        print " TEST CASE # 10: BOOLEAN_BASED_SQL_INJECTION \n "
        print " DESCRIPTION: occurs when data input by a user is interpreted as a SQL command rather than as normal data by the backend database.  \n "
        print " PROCEDURE: Initiating an API call with non-existant app ID \n "
        print " OBSERVATION: GET call should be successful  \n \n "
 
        print "*************************************Checking Boolean Based SQL Injection******************************************"
        try:
          r = requests.get('https://reqres.in/api/unknown/2', auth=('correct_username','wrong_passwd'))
 
          print "Response code: ", r.status_code
#print r.text
#          print r.json()
#print type(r.text)
#          print type(r.json())
        except ValueError as e:
          print "Exception : \n", e
 
        print ('\n\n\n')
 
        print ('\n#######################################################################################################\n')
 
def reqres_with_wrong_credentials():
 
        print " TEST CASE # 11: SUPPLYING WRONG CREDENTIALS \n "
        print " DESCRIPTION: Credential validation is very important in any web application and should be strictly enforced  \n "
        print " PROCEDURE: Doing a POST call to reqres with wrong password \n "
        print " OBSERVATION: GET call shouldn't be successful with error response code  \n \n "
 
        print "*********************************Log in into the reqres with wrong credentials***********************************"
 
        data = {'username':'zarvis', 'password':'wrong_passwd'}
        r = requests.post('https://reqres.in/login', data = data)
        print "Response code: ", r.status_code
#print r.text
#        print r.content
 
 
        print ('\n\n\n')
 
        print ('\n#######################################################################################################\n')
 
def five_times_provide_wrong_credentials_to_reqres():
 
        print " TEST CASE # 12: LOCKING AFTER SOME INVALID LOGIN ATTEMPTS \n "
        print " DESCRIPTION: Credential validation is very important in any web application and should be strictly enforced  \n "
        print " PROCEDURE: Doing a POST call to reqres with wrong password 5 times and then pass on correct creds \n "
        print " OBSERVATION: The last GET call shouldn't be successful and should throw error response code/unauthorized  \n \n "
 
        print "******************************Try to log in into the reqres with 5 times providing wrong credentials**********************"
 
        for i in range(1,6):
                headers = { 'Content-Type': 'application/json' }
                r = requests.get('https://reqres.in/', headers=headers, auth=('zarvis', 'wrong_passwd'))
                print "Response code: ", r.status_code, r.reason
                print "Completed ",i,"Cycle of wrong credential"
 
        print " Providing Correct Credentials and a GET call to service marathon"
        headers = { 'Content-Type': 'application/json' }
        r = requests.get('https://reqres.in/', headers=headers, auth=('zarvis', 'mypasswd'))
        print "Response code: ", r.status_code, r.reason
 
        print ('\n#######################################################################################################\n')
 
def Text_Injection():
 
        print " TEST CASE # 13: TEXT_INJECTION \n "
        print " DESCRIPTION: attack targeting a user made possible by an injection vulnerability in a web application   \n "
        print " PROCEDURE: Adding some unusual strings and special chars after reqres url and doing a GET call \n "
        print " OBSERVATION: Should throw response code as 404 not found  \n \n "
 
        print "*************************************** Text Injection *********************************"
        r = requests.get('https://reqres.in/login/user/klsdjflks8230948029384029uei2][e]pf%20.%20/.,,3@@#&$&&$')
        print "Response code: ", r.status_code
#        print r.content
        print ('\n#######################################################################################################\n')
 
def Denial_of_service_Buffer_Overflows():
 
        print " TEST CASE # 14: DENIAL_OF_SERVICE_BUFFER_OVERFLOWS \n "
        print " DESCRIPTION: serious risk related to a buffer overflow is the ability to execute arbitrary code on the server   \n "
        print " PROCEDURE: Adding some unusual strings and special chars after username and doing a GET call \n "
        print " OBSERVATION: Response code should not be 200 and should throw error as 401 Unauthorized \n \n "
 
        print "*************************************** Denial of service Buffer Overflows ***********************************"
        auth = ('zarvis', 'mypasswd1111111111111118888888888800000000000')
        headers = { 'Content-Type': 'application/json' }
        r = requests.get('https://reqres.in', headers=headers, auth = auth)
        print "Response code: ", r.status_code
#        print r.content
        print ('\n#######################################################################################################\n')
 
def Path_Traversal_Attack():
 
        print " TEST CASE # 15: PATH_TRAVERSAL_ATTACK \n "
        print " DESCRIPTION: attacks exploit various path vulnerabilities to access files or directories that are not intended to be accessed   \n "
        print " PROCEDURE: Adding directory path structure after URL to access a fileand doing a GET call \n "
        print " OBSERVATION: Response code should be 200 and no access to file should be established \n \n "
 
        print "*************************************** Path Traversal Attack ***************************************"
        r = requests.get('https://reqres.in/../../security.pem')
        print "Response code: ", r.status_code
#        print r.content
        print ('\n#######################################################################################################\n')
 
def Send_Receive_Packets_Scapy():
 
        print " TEST CASE # 16: SEND_RECEIVE_PACKETS \n "
        print " DESCRIPTION: Send and receive some packets and analyze it using scapy   \n "
        print " PROCEDURE: NA \n "
        print " OBSERVATION: Analyze output to check for any confidential data \n \n "
 
        print "*************************************** Send_Receive_Packets_Scapy ***************************************"
        output=sr(IP(dst='reqres.in')/ICMP())
        print '\nOutput is:'
        print output
        result, unanswered=output
        print '\nResult is:'
        print result
        print ('\n#######################################################################################################\n')
 
def GET_Call_Scapy():
 
        print " TEST CASE # 17: GET CALL USING SCAPY \n "
        print " DESCRIPTION: Send and receive some packets and analyze it using scapy   \n "
        print " PROCEDURE: NA \n "
        print " OBSERVATION: Analyze output to check for any confidential data in the headers\n \n "
 
        print "*************************************** GET Call Scapy ***************************************"
        # Print info header
        print "[*] ACK-GET example "
 
        # Prepare GET statement
        get='GET / HTTP/1.0\n\n'
 
        # Set up target IP
        ip=IP(dst="reqres.in")
 
        # Generate random source port number
        port=RandNum(1024,65535)
 
        # Create SYN packet
        SYN=ip/TCP(sport=port, dport=80, flags="S", seq=42)
 
        # Send SYN and receive SYN,ACK
        print "\n[*] Sending SYN packet"
        SYNACK=sr1(SYN, retry=-2, timeout=1)
 
        # Create ACK with GET request
        ACK=ip/TCP(sport=SYNACK.dport, dport=80, flags="A", seq=SYNACK.ack, ack=SYNACK.seq + 1) / get
 
        # SEND our ACK-GET request
        print "\n[*] Sending ACK-GET packet"
        reply,error=sr(ACK, retry=-2, timeout=1)
 
        # print reply from server
        print "\n[*] Reply from server:"
        print reply.show()
 
        print '\n[*] Done!'
        print ('\n#######################################################################################################\n')
 
def Check_Cookies():
 
        print " TEST CASE # 18: CHECK_COOKIES \n "
        print " DESCRIPTION: Cookies are major source of risk for any web application and should be kept secured   \n "
        print " PROCEDURE: Doing a GET call to check for all cookies in the headers \n "
        print " OBSERVATION: Analyze output to check for cookies data in the headers\n \n "
        try:
                target = 'https://reqres.in'
                req = requests.get(target)
 
                print req.cookies
                cookies = dict(admin='True')
 
                cookie_req = requests.get(target, cookies=cookies)
 
                for cookie in req.cookies:
                        print 'Name:', cookie.name
                        print 'Value:', cookie.value
                        print 'Secure:', cookie.secure
                        print 'Loosly defined domain:', cookie.domain_initial_dot
 
        except requests.exceptions.RequestException as e:
                print "Exception caught ... \n", e
 
        print ('\n#######################################################################################################\n')
 
def Check_Security_Headers():
 
        print " TEST CASE # 19: CHECK_SECURITY_HEADERS \n "
        print " DESCRIPTION: All headers used for APIs should be checked for any vulnerability   \n "
        print " PROCEDURE: Python script \n "
        print " OBSERVATION: Analyze output to check for insecure/misconfigured headers \n \n "
 
        print "********************************** Check Security Headers ********************************"
 
        w = subprocess.Popen("git clone https://github.com/riramar/hsecscan.git",stdout=subprocess.PIPE,shell=True)
#       print "Changing dir to ..."
        os.chdir('hsecscan')
#        print os.getcwd()
        print "Executing ...."
        subprocess.call('python hsecscan.py -i -u https://reqres.in',shell=True)
#        print x
#       print "Coming back to parent .... "
        os.chdir('../')
#        print os.getcwd()
 
        print ('\n\n\n')
        print ('\n#######################################################################################################\n')
 
 
if __name__ == "__main__":
 
#        tmp_stdout = sys.stdout
#        fw = open("security.txt", "w")
#        sys.stdout = fw
 
        Is_Reqres_Up()
        Register_User()
        sensitive_data_transmitted_in_cleartext()
        SSL_service_recognition_via_nmap()
        Weak_Ciphers_and_SSLv2_via_nmap()
        Client_initiated_Renegotiation_and_Secure_Renegotiation_via_openssl()
        Certificate_authenticity_and_web_related_validations()
        SQL_injection_for_login_page()
        Cross_site_scripting_XSS()
        CrossSite_Request_Forgery_reqres()
        Session_hijacking_in_reqres()
        Boolean_Based_SQL_Injection()
        reqres_with_wrong_credentials()
        five_times_provide_wrong_credentials_to_reqres()
        Text_Injection()
        Denial_of_service_Buffer_Overflows()
        Path_Traversal_Attack()
        Send_Receive_Packets_Scapy()
        GET_Call_Scapy()
        Check_Cookies()
        Check_Security_Headers()
#        sys.stdout = tmp_stdout
#        fw.close()
